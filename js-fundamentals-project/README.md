# Проект: Learning Tracker

## Описание целей проекта
Собрать мини‑приложение для планирования и отслеживания учебных задач. Проект тренирует фундаментальные темы JavaScript (JS Fundamentals из JavaScript.info): работа с данными, условиями, циклами, функциями, объектами и массивами, плюс DOM, события, замыкания и async‑операции.

Идея: у ученика есть список учебных задач (например, «прочитать статью», «разобрать пример», «сделать упражнение»). Он добавляет задачи, задает приоритет, статус, дедлайн, пометки. Приложение считает прогресс, фильтрует, сортирует, сохраняет состояние, умеет подгружать «рекомендованные» задачи асинхронно.

## Общие требования
1) Проект делается в чистом JS без фреймворков.
2) HTML и CSS можно использовать минимальные, но интерфейс должен быть рабочим и понятным.
3) Все данные управляются через состояние в JS (массив объектов задач).
4) Не использовать `innerHTML` для отрисовки списка (безопасность и чистая работа с DOM).
5) Проект должен работать без перезагрузки страницы и не зависеть от внешнего сервера.
6) Допускается локальная имитация async (Promise + setTimeout) либо fetch из локального JSON (если запускаешь через `vite`/`live-server`).

## Список функций (фич), которые нужно реализовать
1) Добавление новой задачи через форму.
2) Отрисовка списка задач на странице.
3) Изменение статуса задачи (todo → in-progress → done).
4) Удаление задачи.
5) Фильтры по статусу и приоритету.
6) Поиск по те сту.
7) Сортировка по дедлайну и по дате создания.
8) Счетчики: всего задач / выполнено / процент выполнения.
9) Сохранение состояния в `localStorage` и восстановление при перезагрузке.
10) Асинхронная загрузка «рекомендованных» задач и добавление их в список.
11) История изменений (минимальный лог: что и когда произошло).

## Подзадачи / итерации с пояснениями

### Итерация 1. Модель данных (массив объектов)
- Опиши структуру задачи:
  ```js
  {
    id: "t-001",
    title: "Разобрать типы данных",
    status: "todo", // todo | in-progress | done
    priority: "medium", // low | medium | high
    createdAt: 1700000000000,
    deadline: 1700500000000,
    notes: "",
  }
  ```
- Функции: `createTask`, `validateTask`, `toggleStatus`, `removeTask`.

Пример входа/выхода:
- Вход: `createTask({ title: "Изучить сравнения", priority: "high" })`
- Выход: объект задачи с `id`, `status: "todo"`, `createdAt`.

### Итерация 2. Отрисовка DOM
- Функции: `renderTasks(list)`, `renderTaskItem(task)`, `renderStats(tasks)`.
- Не использовать `innerHTML` для списка: создавай элементы через `document.createElement`.

Пример:
- Вход: массив из 3 задач
- Выход: 3 элемента в списке + корректные счетчики (например, `Всего: 3`, `Готово: 1`).

### Итерация 3. События и изменение статуса
- Кнопки у задачи: `Next status`, `Delete`.
- Использовать делегирование событий на контейнер списка.

Пример:
- Клик по `Next status` переводит `todo → in-progress`, повторный клик `in-progress → done`.

### Итерация 4. Фильтры и поиск
- Фильтры: статус, приоритет.
- Поиск по подстроке в `title`.
- Функция: `applyFilters(tasks, { status, priority, query })`.

Пример:
- Вход: `{ status: "done", query: "js" }`
- Выход: только завершенные задачи, в названии которых есть "js".

### Итерация 5. Сортировка
- Сортировки: по `deadline`, по `createdAt`.
- Функция: `sortTasks(tasks, mode)`.

Пример:
- Вход: `mode = "deadline"`
- Выход: задачи в порядке ближайшего дедлайна.

### Итерация 6. LocalStorage
- Сохранение при каждом изменении.
- Восстановление при старте.
- Функции: `saveTasks`, `loadTasks`.

Пример:
- Вход: `saveTasks([..])`
- Выход: после перезагрузки список восстанавливается.

### Итерация 7. Async подгрузка
- Имитация API: `fetchRecommendations()` возвращает Promise с массивом задач.
- Добавление этих задач в список с отметкой `source: "recommended"`.

Пример:
- Вход: вызов `fetchRecommendations()`
- Выход: через 500–1000 мс 3 новые задачи добавлены в список.

### Итерация 8. История изменений (замыкания)
- Реализуй лог событий через замыкание: `createLogger()` возвращает функцию, которая пишет лог.
- Лог хранит последние 10 событий.

Пример:
- Вход: `logger("task-added", id)`
- Выход: массив событий `[ { type, payload, timestamp } ]`.

## Примеры ввода и вывода (сводно)
- `createTask({ title: "Learn DOM" })` → `{ id: "t-...", status: "todo", ... }`
- `toggleStatus(task)` → `todo → in-progress → done`
- `applyFilters(tasks, { status: "todo", priority: "high" })` → только высокие в todo
- `sortTasks(tasks, "deadline")` → отсортированный массив
- `fetchRecommendations()` → Promise → массив новых задач
- `logger("task-deleted", "t-004")` → запись в истории

## Критерии оценки / чек-лист

### Функциональность
- Все фичи из списка реализованы.
- Нет расхождений между состоянием в JS и DOM.
- Обновление интерфейса происходит без перезагрузки страницы.

### Обработка ошибок
- Валидация: нельзя добавить задачу с пустым названием.
- Невалидные значения статуса/приоритета не ломают приложение.
- Асинхронная загрузка корректно обрабатывает ошибку (покажи сообщение в UI).

### UX и UI (минимум)
- Видимые элементы управления: форма добавления, фильтры, сортировка, список задач, блок статистики.
- Кнопки имеют понятные названия.
- Фокус доступен с клавиатуры (Tab) для основных действий.
- Список задач читаем: статус/приоритет/дедлайн видны.

### Качество кода
- Нет дублирования логики рендера.
- Мутирования состояния контролируемы.
- Функции небольшие и делают одну задачу.

## Дополнительные рекомендации
- Держи один источник правды: массив `tasks` в памяти.
- Рендери список полностью после каждого изменения, а не обновляй вручную частями (пока учишься).
- Приоритет и статус лучше хранить в виде перечислений (строковых констант).
- Для async добавь индикатор загрузки и кнопку «Загрузить рекомендации».

